{ config, lib, ... }:

with lib;

let
  podman-lib = import ./podman-lib.nix { inherit lib; };

  createQuadletSource = name: containerDef:
    let
      ### Definitions
      serviceName = name;
      containerName = name; # Use the submodule name as the container name
      mergedServiceConfig = podman-lib.serviceConfigDefaults
        // containerDef.serviceConfig;
      mergedUnitConfig = podman-lib.unitConfigDefaults
        // containerDef.unitConfig;
      ###

      ### Helpers
      ifNotNull = condition: text: if condition != null then text else "";
      ifNotEmptyList = list: text: if list != [ ] then text else "";
      ifNotEmptySet = set: text: if set != { } then text else "";
      ###

      ### Formatters
      formatExtraConfig = podman-lib.formatExtraConfig;
      formatPrimitiveValue = podman-lib.formatPrimitiveValue;

      formatNetworkDependencies = networks:
        let formatElement = network: "podman-${network}-network.service";
        in concatStringsSep " " (map formatElement networks);

      formatEnvironment = env:
        if env != { } then
          concatStringsSep " "
          (mapAttrsToList (k: v: "${k}=${formatPrimitiveValue v}") env)
        else
          "";

      formatPorts = ports:
        if ports != [ ] then
          concatStringsSep "\n" (map (port: "PublishPort=${port}") ports)
        else
          "";

      formatVolumes = volumes:
        if volumes != [ ] then
          concatStringsSep "\n" (map (volume: "Volume=${volume}") volumes)
        else
          "";

      formatDevices = devices:
        if devices != [ ] then
          concatStringsSep "\n" (map (device: "AddDevice=${device}") devices)
        else
          "";

      formatCapabilities = action: capabilities:
        if capabilities != [ ] then
          concatStringsSep "\n"
          (map (capability: "${action}Capability=${capability}") capabilities)
        else
          "";

      formatLabels = labels:
        if labels != [ ] then
          concatStringsSep "\n" (map (label: "Label=${label}") labels)
        else
          "";

      formatAutoUpdate = autoupdate:
        if autoupdate == "registry" then
          "AutoUpdate=registry"
        else if autoupdate == "local" then
          "AutoUpdate=local"
        else
          "";

      # TODO: check this against networkMode option. IE, if 'host' there are no bridge networks, etc
      formatBridgeNetworks = containerDef:
        if containerDef.networks != [ ] then
          "Network=${concatStringsSep "," containerDef.networks}"
        else
          "";

      formatPodmanArgs = containerDef:
        let
          networkAliasArg = if containerDef.networkAlias != null then
            "--network-alias ${containerDef.networkAlias}"
          else
            null;
          entrypointArg = if containerDef.entrypoint != null then
            "--entrypoint ${containerDef.entrypoint}"
          else
            null;
          allArgs = [ networkAliasArg entrypointArg ]
            ++ containerDef.extraOptions;
        in if allArgs != [ ] && allArgs != [ "" ] then
          "PodmanArgs=${
            concatStringsSep " "
            (filter (arg: arg != null && arg != "") allArgs)
          }"
        else
          "";
      ###

      configText = ''
        # Automatically generated by home-manager podman container configuration
        # DO NOT EDIT THIS FILE DIRECTLY
        #
        # ${serviceName}.container
        [Unit]
        Description=${
          if containerDef.description != null then
            containerDef.description
          else
            "Service for container ${containerName}"
        }
        After=network.target ${formatNetworkDependencies containerDef.networks}
        ${ifNotEmptyList containerDef.networks
        "Requires=${formatNetworkDependencies containerDef.networks}"}
        ${formatExtraConfig mergedUnitConfig}

        [Container]
        ContainerName=${containerName}
        Image=${containerDef.image}
        Label=nix.home-manager.managed=true
        ${ifNotEmptySet containerDef.environment
        "Environment=${formatEnvironment containerDef.environment}"}
        ${ifNotNull containerDef.environmentFile
        "EnvironmentFile=${containerDef.environmentFile}"}
        ${ifNotNull containerDef.command "Exec=${containerDef.command}"}
        ${ifNotNull containerDef.user
        "User=${formatPrimitiveValue containerDef.user}"}
        ${ifNotNull containerDef.userNS "UserNS=${containerDef.userNS}"}
        ${ifNotNull containerDef.group
        "Group=${formatPrimitiveValue containerDef.group}"}
        ${ifNotEmptyList containerDef.ports (formatPorts containerDef.ports)}
        ${ifNotNull containerDef.networkMode
        "Network=${containerDef.networkMode}"}
        ${formatBridgeNetworks containerDef}
        ${ifNotNull containerDef.ip4 "IP=${containerDef.ip4}"}
        ${ifNotNull containerDef.ip6 "IP6=${containerDef.ip6}"}
        ${ifNotEmptyList containerDef.volumes
        (formatVolumes containerDef.volumes)}
        ${ifNotEmptyList containerDef.devices
        (formatDevices containerDef.devices)}
        ${formatAutoUpdate containerDef.autoupdate}
        ${ifNotEmptyList containerDef.addCapabilities
        (formatCapabilities "Add" containerDef.addCapabilities)}
        ${ifNotEmptyList containerDef.dropCapabilities
        (formatCapabilities "Drop" containerDef.dropCapabilities)}
        ${ifNotEmptyList containerDef.labels (formatLabels containerDef.labels)}
        ${formatPodmanArgs containerDef}
        ${formatExtraConfig containerDef.extraContainerConfig}

        [Service]
        Environment="PATH=/run/wrappers/bin:/run/current-system/sw/bin:${config.home.homeDirectory}/.nix-profile/bin"
        ${formatExtraConfig mergedServiceConfig}

        [Install]
        ${if containerDef.autostart then
          "WantedBy=multi-user.target default.target"
        else
          ""}
      '';

      removeBlankLines = text:
        let
          lines = splitString "\n" text;
          nonEmptyLines = filter (line: line != "") lines;
        in concatStringsSep "\n" nonEmptyLines;

    in removeBlankLines configText;

  toQuadletInternal = name: containerDef:
    let
      allAssertions =
        (podman-lib.buildConfigAsserts name containerDef.serviceConfig
          podman-lib.serviceConfigTypeRules)
        ++ (podman-lib.buildConfigAsserts name containerDef.unitConfig
          podman-lib.unitConfigTypeRules);
    in {
      serviceName = "podman-${name}";
      source = createQuadletSource name containerDef;
      resourceType = "container";
      assertions = allAssertions;
    };

in let
  # Define the container user type as the user interface
  containerDefinitionType = types.submodule {
    options = {
      description = mkOption {
        type = with types; nullOr str;
        description = "The description of the container.";
        default = null;
      };

      image = mkOption {
        type = types.str;
        description = "The container image.";
      };

      entrypoint = mkOption {
        type = with types; nullOr str;
        description = "The container entrypoint.";
        default = null;
      };

      command = mkOption {
        type = with types; nullOr str;
        description = "The command to run after the container specification.";
        default = null;
      };

      environment = mkOption {
        type = podman-lib.primitiveAttrs;
        description = "Environment variables to set in the container";
        default = { };
        example = literalMD ''
          ```
          environment = {
            VAR1 = "0:100";
            VAR2 = true;
            VAR3 = 5;
          };
          ```
        '';
      };

      environmentFile = mkOption {
        type = with types; nullOr str;
        default = null;
        description =
          "Path to a file containing environment variables to set in the container.";
        example = literalMD ''
          `environmentFile = "/etc/environment";`
        '';
      };

      ports = mkOption {
        type = with types; listOf str;
        default = [ ];
        description = "A mapping of ports between host and container";
        example = literalMD ''
          `ports = [ "8080:80" ];`
        '';
      };

      user = mkOption {
        type = with types; nullOr (oneOf [ str int ]);
        default = null;
        description = "The user ID inside the container.";
      };

      userNS = mkOption {
        type = with types; nullOr str;
        default = null;
        description = "Use a user namespace for the container.";
      };

      group = mkOption {
        type = with types; nullOr (oneOf [ str int ]);
        default = null;
        description = "The group ID inside the container.";
      };

      networkMode = mkOption {
        type = with types; nullOr str;
        default = null;
        description = "The network mode for the container.";
      };

      networks = mkOption {
        type = with types; listOf str;
        default = [ ];
        description =
          "The networks to connect the container to. Best that these networks are defined with services.podman.networks";
        example = literalMD ''
          `networks = [ "mynet" ];`
        '';
      };

      ip4 = mkOption {
        type = with types; nullOr str;
        default = null;
        description = "Set an IPv4 address for the container.";
      };

      ip6 = mkOption {
        type = with types; nullOr str;
        default = null;
        description = "Set an IPv6 address for the container.";
      };

      networkAlias = mkOption {
        type = with types; nullOr str;
        default = null;
        description = "Set a network alias for the container.";
      };

      volumes = mkOption {
        type = with types; listOf str;
        default = [ ];
        description = "The volumes to mount into the container.";
        example = literalMD ''
          ```
          volumes = [
            "/tmp:/tmp"
            "/var/run/test.secret:/etc/secret:ro"
          ];
          ```
        '';
      };

      devices = mkOption {
        type = types.listOf types.str;
        default = [ ];
        description =
          "The devices to mount into the container, in the format '/dev/<host>:/dev/<container>'.";
      };

      autoupdate = mkOption {
        type = with types; enum [ "" "registry" "local" ];
        default = "";
        description = "The autoupdate policy for the container.";
        example = literalMD ''
          `autoupdate = "registry"`;
        '';
      };

      autostart = mkOption {
        type = types.bool;
        default = true;
        description =
          "Whether to start the container on user login / boot (requires user lingering).";
      };

      addCapabilities = mkOption {
        type = with types; listOf str;
        default = [ ];
        description = "The capabilities to add to the container.";
      };

      dropCapabilities = mkOption {
        type = with types; listOf str;
        default = [ ];
        description = "The capabilities to drop from the container.";
      };

      labels = mkOption {
        type = with types; listOf str;
        default = [ ];
        description = "The labels to apply to the container.";
      };

      extraOptions = mkOption {
        type = with types; listOf str;
        default = [ ];
        description = "Extra options to pass to the podman run command.";
      };

      extraContainerConfig = mkOption {
        type = podman-lib.primitiveAttrs;
        default = { };
        description = "Extra configuration, in Podman Quadlet format.";
        example = literalMD ''
          ```
          extraContainerConfig = {
            UIDMap = "0:1000:1";
            ReadOnlyTmpfs = true;
            EnvironmentFile = [ /etc/environment /root/.env];
          };
          ```
        '';
      };

      serviceConfig = mkOption {
        type = podman-lib.serviceConfigType;
        default = { };
        description =
          "Configuration values for the systemd service for the container.";
      };

      unitConfig = mkOption {
        type = podman-lib.unitConfigType;
        default = { };
        description =
          "Configuration values for the systemd unit for the container.";
      };

    };
  };

in {

  imports = [ ./options.nix ];

  options.services.podman.containers = mkOption {
    type = types.attrsOf containerDefinitionType;
    default = { };
    description = "Attribute set of container definitions.";
  };

  config = let
    containerQuadlets =
      mapAttrsToList toQuadletInternal config.services.podman.containers;
  in {
    internal.podman-quadlet-definitions = containerQuadlets;
    assertions =
      flatten (map (container: container.assertions) containerQuadlets);

    # manifest file
    home.file."${config.xdg.configHome}/podman/containers.manifest".text =
      podman-lib.generateManifestText containerQuadlets;
  };
}
