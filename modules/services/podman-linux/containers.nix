{ config, lib, pkgs, ... }:

with lib;

let
  podman-lib = import ./podman-lib.nix { inherit lib; };

  createQuadletSource = name: containerDef:
    let
      ### Definitions
      mergedInstallConfig = podman-lib.installConfigDefaults
        // containerDef.extraInstallConfig;
      mergedServiceConfig = podman-lib.serviceConfigDefaults
        // containerDef.extraServiceConfig;
      mergedUnitConfig = podman-lib.unitConfigDefaults
        // containerDef.extraUnitConfig;
      ###

      ### Helpers
      ifAttrList = podman-lib.sourceHelpers.ifAttrList;
      ifAttrSet = podman-lib.sourceHelpers.ifAttrSet;
      ifAttrString = podman-lib.sourceHelpers.ifAttrString;
      ifNotEmptyList = podman-lib.sourceHelpers.ifNotEmptyList;
      ifNotEmptySet = podman-lib.sourceHelpers.ifNotEmptySet;
      ifNotNull = podman-lib.sourceHelpers.ifNotNull;
      ###

      ### Formatters
      formatAutoUpdate = podman-lib.formatAutoUpdate;
      formatExtraConfig = podman-lib.formatExtraConfig;
      formatLabels = podman-lib.formatLabels;
      formatListNewlines = podman-lib.formatListNewlines;
      formatListSpaces = podman-lib.formatListSpaces;
      formatNetworks = podman-lib.formatNetworks;
      formatSetSpaces = podman-lib.formatSetSpaces;
      formatNetworkDependencies = podman-lib.formatNetworkDependencies;
      formatPodmanArgs = podman-lib.formatPodmanArgs;
      formatPrimitiveValue = podman-lib.formatPrimitiveValue;
      ###

      servicePath = concatStringsSep ":" [
        "/run/wrappers/bin"
        "/run/current-system/sw/bin"
        "${config.home.homeDirectory}/.nix-profile/bin"
      ];
    in ''
      # Automatically generated by home-manager podman container configuration
      # DO NOT EDIT THIS FILE DIRECTLY
      #
      # ${name}.container
      [Unit]
      Description=${
        if (builtins.hasAttr "Description" containerDef.extraUnitConfig) then
          containerDef.extraUnitConfig.Description
        else if containerDef.description != null then
          containerDef.description
        else
          "Service for container ${name}"
      }
      After=network.target ${formatNetworkDependencies containerDef.networks}
      ${ifNotEmptyList containerDef.networks
      "Requires=${formatNetworkDependencies containerDef.networks}"}
      ${formatExtraConfig mergedUnitConfig "Unit"}

      [Container]
      ${ifNotEmptyList (containerDef.addCapabilities
        ++ (ifAttrList containerDef.extraContainerConfig "AddCapability"))
      (formatListSpaces (containerDef.addCapabilities
        ++ (ifAttrList containerDef.extraContainerConfig "AddCapability"))
        "AddCapability")}
      ${formatAutoUpdate
      (if (builtins.hasAttr "AutoUpdate" containerDef.extraContainerConfig) then
        containerDef.extraContainerConfig.AutoUpdate
      else
        ifNotNull containerDef.autoupdate)}
      ContainerName=${
        if (builtins.hasAttr "ContainerName"
          containerDef.extraContainerConfig) then
          containerDef.extraContainerConfig.ContainerName
        else
          name
      }
      ${ifNotEmptyList (containerDef.devices
        ++ (ifAttrList containerDef.extraContainerConfig "Device"))
      (formatListSpaces (containerDef.devices
        ++ (ifAttrList containerDef.extraContainerConfig "Device"))
        "AddDevice")}
      ${ifNotEmptyList (containerDef.dropCapabilities
        ++ (ifAttrList containerDef.extraContainerConfig "DropCapability"))
      (formatListSpaces (containerDef.DropCapabilities
        ++ (ifAttrList containerDef.extraContainerConfig "DropCapability"))
        "DropCapability")}
      ${ifNotEmptySet (containerDef.environment
        // (ifAttrSet containerDef.extraContainerConfig "Environment"))
      (formatSetSpaces (containerDef.environment
        // (ifAttrSet containerDef.extraContainerConfig "Environment"))
        "Environment")}
      ${ifNotEmptyList (containerDef.environmentFiles
        ++ (ifAttrList containerDef.extraContainerConfig "EnvironmentFile"))
      (formatListSpaces (containerDef.environmentFile
        ++ (ifAttrList containerDef.extraContainerConfig "EnvironmentFile"))
        "EnvironmentFile")}
      ${if (ifAttrString containerDef.extraContainerConfig "Exec" != "") then
        "Exec=${containerDef.extraContainerConfig.Exec}"
      else
        ifNotNull containerDef.exec "Exec=${containerDef.exec}"}
      Image=${
        if (builtins.hasAttr "Image" containerDef.extraContainerConfig) then
          containerDef.extraContainerConfig.Image
        else
          containerDef.image
      }
      ${ifNotEmptyList (containerDef.labels
        ++ (ifAttrList containerDef.extraContainerConfig "Label")) (formatLabels
          (containerDef.labels
            ++ (ifAttrList containerDef.extraContainerConfig "Label")))}
      ${ifNotEmptyList (containerDef.networks ++ [ containerDef.networkMode ]
        ++ (ifAttrList containerDef.extraContainerConfig "Network"))
      (formatNetworks containerDef)}
      ${formatPodmanArgs containerDef}
      ${ifNotEmptyList (containerDef.ports
        ++ (ifAttrList containerDef.extraContainerConfig "PublishPort"))
      (formatListNewlines (containerDef.ports
        ++ (ifAttrList containerDef.extraContainerConfig "PublishPort"))
        "PublishPort")}
      ${ifNotEmptyList (containerDef.volumes
        ++ (ifAttrList containerDef.extraContainerConfig "Volume"))
      (formatListNewlines (containerDef.volumes
        ++ (ifAttrList containerDef.extraContainerConfig "Volume")) "Volume")}
      ${formatExtraConfig containerDef.extraContainerConfig "Container"}

      [Service]
      Environment=PATH=${servicePath}
      ${formatExtraConfig mergedServiceConfig "Service"}

      [Install]
      ${if containerDef.autostart then
        "WantedBy=multi-user.target default.target"
      else
        ""}
      ${formatExtraConfig mergedInstallConfig "Install"}

    '';

  toQuadletInternal = name: containerDef:
    let
      allAssertions =
        (podman-lib.buildConfigAsserts name containerDef.extraServiceConfig
          podman-lib.serviceConfigTypeRules)
        ++ (podman-lib.buildConfigAsserts name containerDef.extraUnitConfig
          podman-lib.unitConfigTypeRules);
    in {
      serviceName =
        "podman-${name}"; # quadlet service name: 'podman-<name>.service'
      source =
        podman-lib.removeBlankLines (createQuadletSource name containerDef);
      resourceType = "container";
      assertions = allAssertions;
    };

in let
  # Define the container user type as the user interface
  containerDefinitionType = types.submodule {
    options = {

      addCapabilities = mkOption {
        type = with types; listOf str;
        default = [ ];
        description = "The capabilities to add to the container.";
        example = literalMD ''
          `addCapabilities = [ "CAP_DAC_OVERRIDE" "CAP_IPC_OWNER" ];`
        '';
      };

      autostart = mkOption {
        type = types.bool;
        default = true;
        description =
          "Whether to start the container on boot (requires user lingering).";
      };

      autoupdate = mkOption {
        type = with types; enum [ "" "registry" "local" ];
        default = "";
        description = "The autoupdate policy for the container.";
        example = literalMD ''
          `autoupdate = "registry";`
        '';
      };

      description = mkOption {
        type = with types; nullOr str;
        description = "The description of the container.";
        default = null;
        example = literalMD ''
          `description = "My Container";`
        '';
      };

      devices = mkOption {
        type = types.listOf types.str;
        default = [ ];
        description = "The devices to mount into the container";
        example = literalMD ''
          `devices = [ "/dev/<host>:/dev/<container>" ];`
        '';
      };

      dropCapabilities = mkOption {
        type = with types; listOf str;
        default = [ ];
        description = "The capabilities to drop from the container.";
        example = literalMD ''
          `dropCapabilities = [ "CAP_DAC_OVERRIDE" "CAP_IPC_OWNER" ];`
        '';
      };

      entrypoint = mkOption {
        type = with types; nullOr str;
        description = "The container entrypoint.";
        default = null;
        example = literalMD ''
          `entrypoint = "/foo.sh";`
        '';
      };

      environment = mkOption {
        type = podman-lib.primitiveAttrs;
        description = "Environment variables to set in the container.";
        default = { };
        example = literalMD ''
          ```
          environment = {
            VAR1 = "0:100";
            VAR2 = true;
            VAR3 = 5;
          };
          ```
        '';
      };

      environmentFiles = mkOption {
        type = with types; listOf str;
        default = [ ];
        description =
          "Paths to files containing container environment variables.";
        example = literalMD ''
          `environmentFiles = [ "/etc/environment" ];`
        '';
      };

      exec = mkOption {
        type = with types; nullOr str;
        description = "The command to run after the container start.";
        default = null;
        example = literalMD ''
          `exec = "sleep inf";`
        '';
      };

      extraContainerConfig = mkOption {
        type = podman-lib.primitiveAttrs;
        default = { };
        description =
          "Extra configs for container quadlet's Container section.";
        example = literalMD ''
          ```
          extraContainerConfig = {
            UIDMap = "0:1000:1";
            ReadOnlyTmpfs = true;
            EnvironmentFile = [ /etc/environment /root/.env];
          };
          ```
        '';
      };

      extraInstallConfig = mkOption {
        type = podman-lib.primitiveAttrs;
        default = { };
        description = "Extra configs for container quadlet's Install section.";
      };

      extraPodmanArgs = mkOption {
        type = with types; listOf str;
        default = [ ];
        description = "Extra arguments to pass to the podman run command.";
      };

      extraServiceConfig = mkOption {
        type = podman-lib.serviceConfigType;
        default = { };
        description = "Extra configs for container quadlet's Container section";
        example = literalMD ''
          ```
            extraServiceConfig = {
              TimeoutStartSec = 15;
            };
          ```
        '';
      };

      extraUnitConfig = mkOption {
        type = podman-lib.unitConfigType;
        default = { };
        description = "Extra configs for container quadlet's Unit section";
        example = literalMD ''
          ```
            extraUnitConfig = {
              Description = "My network configuration file";
            };
          ```
        '';
      };

      image = mkOption {
        type = types.str;
        description = "The container image.";
        example = literalMD ''
          `image = "registry.access.redhat.com/ubi9-minimal:latest";`
        '';
      };

      labels = mkOption {
        type = with types; listOf str;
        default = [ ];
        description = "The labels to apply to the container.";
        example = literalMD ''
          ```
          labels = {
            app = "myapp";
            "some-label" = "somelabel";
          };
          ```
        '';
      };

      ports = mkOption {
        type = with types; listOf str;
        default = [ ];
        description = "A mapping of ports between host and container";
        example = literalMD ''
          `ports = [ "8080:80" ];`
        '';
      };

      networkMode = mkOption {
        type = with types; nullOr str;
        default = null;
        description = "The network mode for the container.";
        example = literalMD ''
          `networkMode = "host";`
        '';
      };

      networks = mkOption {
        type = with types; listOf str;
        default = [ ];
        description = "The networks to connect the container to. "
          + "Best that these networks are defined with services.podman.networks.";
        example = literalMD ''
          `networks = [ "mynet" ];`
        '';
      };

      networkAliases = mkOption {
        type = with types; listOf str;
        default = [ ];
        description = "Network aliases for the container.";
        example = literalMD ''
          `networkAliases = [ "mycontainer" "web" ];`
        '';
      };

      volumes = mkOption {
        type = with types; listOf str;
        default = [ ];
        description = "The volumes to mount into the container.";
        example = literalMD ''
          ```
          volumes = [
            "/tmp:/tmp"
            "/var/run/test.secret:/etc/secret:ro"
          ];
          ```
        '';
      };
    };
  };

in {

  imports = [ ./options.nix ];

  options.services.podman.containers = mkOption {
    type = types.attrsOf containerDefinitionType;
    default = { };
    description = "Defines Podman container quadlet configurations.";
  };

  config = let
    containerQuadlets =
      mapAttrsToList toQuadletInternal config.services.podman.containers;
  in mkIf pkgs.stdenv.isLinux {
    internal.podman-quadlet-definitions = containerQuadlets;
    assertions =
      flatten (map (container: container.assertions) containerQuadlets);

    # manifest file
    home.file."${config.xdg.configHome}/podman/containers.manifest".text =
      podman-lib.generateManifestText containerQuadlets;
  };
}
