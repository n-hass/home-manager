{ config, lib, pkgs, ... }:

with lib;

let
  podman-lib = import ./podman-lib.nix { inherit lib config; };

  createQuadletSource = name: containerDef:
    let
      mapHmNetworks = network:
        if builtins.hasAttr network config.services.podman.networks then
          "podman-${network}-network.service"
        else
          null;

      finalConfig = let
        managedNetworks = if lib.isList containerDef.network then
          map mapHmNetworks containerDef.network
        else if containerDef.network != null then
          map mapHmNetworks [ containerDef.network ]
        else
          [ ];
      in (podman-lib.deepMerge {
        Container = {
          AddCapability = containerDef.addCapabilities;
          AddDevice = containerDef.devices;
          AutoUpdate = containerDef.autoUpdate;
          ContainerName = name;
          DropCapability = containerDef.dropCapabilities;
          Entrypoint = containerDef.entrypoint;
          Environment = containerDef.environment;
          EnvironmentFile = containerDef.environmentFile;
          Exec = containerDef.exec;
          Group = containerDef.group;
          Image = containerDef.image;
          IP = containerDef.ip4;
          IP6 = containerDef.ip6;
          Label =
            (containerDef.labels // { "nix.home-manager.managed" = true; });
          Network = containerDef.network;
          NetworkAlias = containerDef.networkAlias;
          PodmanArgs = containerDef.extraOptions;
          PublishPort = containerDef.ports;
          UserNS = containerDef.userNS;
          User = containerDef.user;
          Volume = containerDef.volumes;
        };
        Install = {
          WantedBy = (if containerDef.autoStart then [
            "default.target"
            "multi-user.target"
          ] else
            [ ]);
        };
        Service = {
          Environment = {
            PATH = (builtins.concatStringsSep ":" [
              "/run/wrappers/bin"
              "/run/current-system/sw/bin"
              "${config.home.homeDirectory}/.nix-profile/bin"
            ]);
          };
          Restart = "always";
          TimeoutStopSec = 30;
        };
        Unit = {
          After = [ "network.target" ] ++ managedNetworks;
          Requires = managedNetworks;
          Description = (if (builtins.isString containerDef.description) then
            containerDef.description
          else
            "Service for container ${name}");
        };
      } containerDef.extraConfig);
    in ''
      # Automatically generated by home-manager podman container configuration
      # DO NOT EDIT THIS FILE DIRECTLY
      #
      # ${name}.container
      ${podman-lib.toQuadletIni finalConfig}
    '';

  toQuadletInternal = name: containerDef:
    let
      allAssertions = (map (section:
        if builtins.hasAttr section containerDef.extraConfig then
          (podman-lib.buildConfigAsserts name section
            containerDef.extraConfig."${section}")
        else
          [ ]) [ "Container" "Install" "Service" "Unit" ]);
    in {
      assertions = allAssertions;
      resourceType = "container";
      serviceName =
        "podman-${name}"; # quadlet service name: 'podman-<name>.service'
      source =
        podman-lib.removeBlankLines (createQuadletSource name containerDef);
    };

in let
  # Define the container user type as the user interface
  containerDefinitionType = types.submodule {
    options = {

      addCapabilities = mkOption {
        type = with types; either str (listOf str);
        default = [ ];
        description = "The capabilities to add to the container.";
        example = literalMD ''
          `addCapabilities = [ "CAP_DAC_OVERRIDE" "CAP_IPC_OWNER" ];`
        '';
      };

      autoStart = mkOption {
        type = types.bool;
        default = true;
        description =
          "Whether to start the container on boot (requires user lingering).";
      };

      autoUpdate = mkOption {
        type = with types; enum [ null "registry" "local" ];
        default = null;
        description = "The autoupdate policy for the container.";
        example = literalMD ''
          `autoUpdate = "registry";`
        '';
      };

      description = mkOption {
        type = with types; nullOr str;
        description = "The description of the container.";
        default = null;
        example = literalMD ''
          `description = "My Container";`
        '';
      };

      devices = mkOption {
        type = with types; either str (listOf str);
        default = [ ];
        description = "The devices to mount into the container";
        example = literalMD ''
          `devices = "/dev/null:/dev/null";`
          or
          `devices = [ "/dev/<host>:/dev/<container>" ];`
        '';
      };

      dropCapabilities = mkOption {
        type = with types; either str (listOf str);
        default = [ ];
        description = "The capabilities to drop from the container.";
        example = literalMD ''
          `dropCapabilities = "CAP_DAC_OVERRIDE";`
          or
          `dropCapabilities = [ "CAP_DAC_OVERRIDE" "CAP_IPC_OWNER" ];`
        '';
      };

      entrypoint = mkOption {
        type = with types; nullOr str;
        description = "The container entrypoint.";
        default = null;
        example = literalMD ''
          `entrypoint = "/foo.sh";`
        '';
      };

      environment = mkOption {
        type = podman-lib.primitiveAttrs;
        description = "Environment variables to set in the container.";
        default = { };
        example = literalMD ''
          ```
          environment = {
            VAR1 = "0:100";
            VAR2 = true;
            VAR3 = 5;
          };
          ```
        '';
      };

      environmentFile = mkOption {
        type = with types; either str (listOf str);
        default = [ ];
        description =
          "Paths to files containing container environment variables.";
        example = literalMD ''
          `environmentFile = "/etc/environment";`
          or
          `environmentFile = [ "/etc/environment" "/etc/other-env" ];`
        '';
      };

      exec = mkOption {
        type = with types; nullOr str;
        description = "The command to run after the container start.";
        default = null;
        example = literalMD ''
          `exec = "sleep inf";`
        '';
      };

      extraOptions = mkOption {
        type = with types; either str (listOf str);
        default = [ ];
        description = "Extra arguments to pass to the podman run command.";
        example = literalMD ''
          `extraOptions = "--security-opt=no-new-privileges";`
          or
          `extraOptions = [ "--security-opt=no-new-privileges" "--security-opt=seccomp=unconfined" ];`
        '';
      };

      extraConfig = mkOption {
        type = podman-lib.extraConfigType;
        default = { };
        description =
          "INI sections and values to populate the Container Quadlet";
        example = literalMD ''
          ```
          extraConfig = {
            Container = {
              User = 1000;
            };
            Service = {
              TimeoutStartSec = 15;
            };
          };
          ```
        '';
      };

      group = mkOption {
        type = with types; nullOr (oneOf [ int str ]);
        default = null;
        description = "The group ID inside the container.";
      };

      image = mkOption {
        type = types.str;
        description = "The container image.";
        example = literalMD ''
          `image = "registry.access.redhat.com/ubi9-minimal:latest";`
        '';
      };

      ip4 = mkOption {
        type = with types; nullOr str;
        default = null;
        description = "Set an IPv4 address for the container.";
      };

      ip6 = mkOption {
        type = with types; nullOr str;
        default = null;
        description = "Set an IPv6 address for the container.";
      };

      labels = mkOption {
        type = with types; attrsOf str;
        default = { };
        description = "The labels to apply to the container.";
        example = literalMD ''
          ```
          labels = {
            app = "myapp";
            "some-label" = "somelabel";
          };
          ```
        '';
      };

      network = mkOption {
        type = with types; either str (listOf str);
        default = [ ];
        description =
          "The network mode or network/s to connect the container to. Equivalent to `podman run --network=<option>`";
        example = literalMD ''
          `network = "host";`
          or
          `network = "bridge_network_1";`
          or
          `network = [ "bridge_network_1" "bridge_network_2" ];`
        '';
      };

      networkAlias = mkOption {
        type = with types; either str (listOf str);
        default = [ ];
        description = "Network aliases for the container.";
        example = literalMD ''
          `networkAlias = "mycontainer";`
          or
          `networkAlias = [ "mycontainer" "web" ];`
        '';
      };

      ports = mkOption {
        type = with types; either str (listOf str);
        default = [ ];
        description = "A mapping of ports between host and container";
        example = literalMD ''
          `ports = "8080:80";`
          or
          `ports = [ "8080:80" "8443:443" ];`
        '';
      };

      userNS = mkOption {
        type = with types; nullOr str;
        default = null;
        description = "Use a user namespace for the container.";
      };

      user = mkOption {
        type = with types; nullOr (oneOf [ int str ]);
        default = null;
        description = "The user ID inside the container.";
      };

      volumes = mkOption {
        type = with types; either str (listOf str);
        default = [ ];
        description = "The volumes to mount into the container.";
        example = literalMD ''
          ```
          volumes = [
            "/tmp:/tmp"
            "/var/run/test.secret:/etc/secret:ro"
          ];
          ```
        '';
      };
    };
  };

in {

  imports = [ ./options.nix ];

  options.services.podman.containers = mkOption {
    type = types.attrsOf containerDefinitionType;
    default = { };
    description = "Defines Podman container quadlet configurations.";
  };

  config = let
    containerQuadlets =
      mapAttrsToList toQuadletInternal config.services.podman.containers;
  in mkIf pkgs.stdenv.isLinux {
    services.podman.internal.quadlet-definitions = containerQuadlets;
    assertions =
      flatten (map (container: container.assertions) containerQuadlets);

    # manifest file
    home.file."${config.xdg.configHome}/podman/containers.manifest".text =
      podman-lib.generateManifestText containerQuadlets;
  };
}
