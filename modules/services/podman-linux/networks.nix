{ config, lib, pkgs, ... }:

with lib;

let
  podman-lib = import ./podman-lib.nix { inherit lib config; };

  awaitPodmanUnshare = pkgs.writeShellScript "await-podman-unshare" ''
    until ${config.services.podman.package}/bin/podman unshare ${pkgs.coreutils}/bin/true; do
      sleep 1;
    done
  '';

  createQuadletSource = name: networkDef:
    let
      cfg = (podman-lib.deepMerge {
        Install = {
          WantedBy = (if networkDef.autoStart then [
            "default.target"
            "multi-user.target"
          ] else
            [ ]);
        };
        Network = {
          Driver = networkDef.driver;
          Gateway = networkDef.gateway;
          Internal = networkDef.internal;
          NetworkName = name;
          Label = networkDef.labels // { "nix.home-manager.managed" = true; };
          PodmanArgs = networkDef.extraOptions;
          Subnet = networkDef.subnet;
        };
        Service = {
          Environment = {
            PATH = (builtins.concatStringsSep ":" [
              "${podman-lib.newuidmapPaths}"
              "${makeBinPath [ pkgs.su pkgs.coreutils ]}"
            ]);
          };
          ExecStartPre = [ "${awaitPodmanUnshare}" ];
          TimeoutStartSec = 15;
          RemainAfterExit = "yes";
        };
        Unit = {
          After = [ "network.target" ];
          Description = (if (builtins.isString networkDef.description) then
            networkDef.description
          else
            "Service for network ${name}");
        };
      } networkDef.extraConfig);
    in ''
      # Automatically generated by home-manager for podman network configuration
      # DO NOT EDIT THIS FILE DIRECTLY
      #
      # ${name}.network
      ${podman-lib.toQuadletIni cfg}
    '';

  toQuadletInternal = name: networkDef:
    let
      allAssertions = (map (section:
        if builtins.hasAttr section networkDef.extraConfig then
          (podman-lib.buildConfigAsserts name section
            networkDef.extraConfig."${section}")
        else
          [ ]) [ "Install" "Network" "Service" "Unit" ]);
    in {
      assertions = allAssertions;
      serviceName =
        "podman-${name}"; # quadlet service name: 'podman-<name>-network.service'
      source =
        podman-lib.removeBlankLines (createQuadletSource name networkDef);
      resourceType = "network";
    };

in let
  networkDefinitionType = types.submodule {
    options = {

      autoStart = mkOption {
        type = types.bool;
        default = true;
        description =
          "Whether to start the network on boot (requires user lingering).";
      };

      description = mkOption {
        type = with types; nullOr str;
        description = "The description of the network.";
        default = null;
        example = literalMD ''
          `description = "My Network";`
        '';
      };

      driver = mkOption {
        type = with types; nullOr str;
        default = null;
        description = "The network driver to use.";
        example = literalMD ''
          `driver = "bridge";`
        '';
      };

      extraConfig = mkOption {
        type = podman-lib.extraConfigType;
        default = { };
        description = "INI sections and values to populate the Network Quadlet";
        example = literalMD ''
          ```
          extraConfig = {
            Network = {
              ContainerConfModule = "/etc/nvd.conf";
            };
            Service = {
              TimeoutStartSec = 30;
            };
          };
          ```
        '';
      };

      extraOptions = mkOption {
        type = with types; either str (listOf str);
        default = [ ];
        description = "Extra arguments to pass to the podman network create command.";
        example = literalMD ''
          `extraOptions = "--dns=192.168.55.1";`
          or
          `extraOptions = [ "--dns=192.168.55.1" "--ipam-driver" ];`
        '';
      };

      gateway = mkOption {
        type = with types; nullOr str;
        default = null;
        description = "The gateway IP to use for the network.";
        example = literalMD ''
          `gateway = "192.168.20.1";`
        '';
      };

      internal = mkOption {
        type = with types; nullOr bool;
        default = null;
        description = "Whether the network should be internal";
      };

      labels = mkOption {
        type = with types; attrsOf str;
        default = { };
        description = "The labels to apply to the network.";
        example = literalMD ''
          ```
          labels = {
            app = "myapp";
            "some-label" = "somelabel";
          };
          ```
        '';
      };

      subnet = mkOption {
        type = with types; nullOr str;
        default = null;
        description = "The subnet to use for the network.";
        example = literalMD ''
          `subnet = "192.168.20.0/24";`
        '';
      };

    };
  };
in {
  options.services.podman.networks = mkOption {
    type = types.attrsOf networkDefinitionType;
    default = { };
    description = "Defines Podman network quadlet configurations.";
  };

  config = let
    networkQuadlets =
      mapAttrsToList toQuadletInternal config.services.podman.networks;
  in mkIf pkgs.stdenv.isLinux {
    services.podman.internal.quadlet-definitions = networkQuadlets;
    assertions = flatten (map (network: network.assertions) networkQuadlets);

    home.file."${config.xdg.configHome}/podman/networks.manifest".text =
      podman-lib.generateManifestText networkQuadlets;
  };
}
